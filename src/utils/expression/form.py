from typing import Optional, Tuple, List
from collections import defaultdict

from sympy import Poly, Expr, Integer, Rational, latex
from sympy.core.singleton import S
from sympy.combinatorics import Permutation, PermutationGroup, CyclicGroup

from .coeff import Coeff
from ..polytools import deg
from ..text_process import pl

def _is_single_paren(s: str) -> bool:
    """
    Infer whether the string is wrapped by a single pair of parentheses.
    """
    if not s.startswith('(') or not s.endswith(')'):
        return False
    stack = 0
    m = len(s) - 1
    for i, c in enumerate(s):
        if c == '(':
            stack += 1
        elif c == ')':
            stack -= 1
            if stack == 0 and i != m:
                return False
    return True

def _get_coeff_str(coeff, MUL = '*') -> str:
    """
    Get the coefficient string.
    """
    if isinstance(coeff, Rational):
        if coeff == 1: coeff_str = '+'
        elif coeff == -1: coeff_str = '-'
        elif coeff > 0: coeff_str = '+%s%s'%(coeff, MUL)
        else: coeff_str = '%s%s'%(coeff, MUL)
    else:
        coeff_str = str(coeff).replace('**', '^').replace(' ','')

        if _is_single_paren(coeff_str): pass
        elif coeff_str.startswith('-(') and _is_single_paren(coeff_str[1:]): pass
        else:
            coeff_str = '+(%s)'%coeff_str
        coeff_str += MUL
    return coeff_str

def poly_get_standard_form(
        poly: Poly,
        perm: Optional[PermutationGroup] = None,
        omit_mul: bool = True,
        omit_pow: bool = True,
        _is_cyc: Optional[bool] = None
    ) -> str:
    """
    Express a polynomial in the standard form.

    Parameters
    ----------
    poly : Poly
        The polynomial to be expressed.
    perm : PermutationGroup
        The permutation group to be considered. If None,
        it uses the cyclic group generated by the variables.
    omit_mul : bool
        Whether to omit the multiplication sign. Defaults to True.
    omit_pow : bool
        Whether to omit the power sign. Defaults to True.
    _is_cyc : Optional[bool]
        If it is None, it will be inferred from the permutation group.
        If given, it will be used directly.

    Examples
    --------
    >>> poly_get_standard_form(((x*a+y*b+z*c)**2).as_poly(x,y,z))
    '(a^2)x2+(2*a*b)xy+(2*a*c)xz+(b^2)y2+(2*b*c)yz+(c^2)z2'
    >>> poly_get_standard_form(((x*a+y*b+z*c)**2).as_poly(x,y,z,a,b,c), PermutationGroup(Permutation([1,2,0,4,5,3])))
    's(x2a2+2xyab)'
    """
    if poly.total_degree() == 0:
        # is constant polynomial
        s = str(poly.coeff_monomial((0,) * len(poly.gens)))
        s = s.replace('**', '^').replace(' ','')
        if not _is_single_paren(s):
            s = '(%s)'%s
        return s

    if perm is None:
        perm = CyclicGroup(len(poly.gens))
    if _is_cyc is None:
        _is_cyc = Coeff(poly).is_cyclic(perm)

    extracted = []
    if _is_cyc:
        perm_group_gens = perm.generators
        perm_order = perm.order()
        ufs = {}
        # monomials invariant under the permutation group is recorded in ufs
        def ufs_find(monom):
            v = ufs.get(monom, monom)
            if v == monom:
                return monom
            w = ufs_find(v)
            ufs[monom] = w
            return w
        for m1, coeff in poly.terms():
            for p in perm_group_gens:
                m2 = tuple(p(m1))
                f1, f2 = ufs_find(m1), ufs_find(m2)
                # merge to the maximum
                if f1 > f2:
                    ufs[f2] = f1
                else:
                    ufs[f1] = f2

        ufs_size = defaultdict(int)
        for m in ufs.keys():
            ufs_size[ufs_find(m)] += 1

        def get_order(monom):
            # get the multiplicity of the monomials given the permutation group
            # i.e. how many permutations make it invariant
            return perm_order // ufs_size[ufs_find(monom)]
        
        # only reserve the keys for ufs[monom] == monom
        for monom, coeff in poly.terms():
            if ufs_find(monom) == monom:
                extracted.append((sum(monom), monom, coeff))
    else:
        One = S.One
        def get_order(monom):
            return One
        for monom, coeff in poly.terms():
            extracted.append((sum(monom), monom, coeff))
 
    extracted = sorted(extracted, reverse=True)

    MUL = '*' if not omit_mul else ''
    POW = '^' if not omit_pow else ''
    gens = poly.gens
    nvars = len(gens)
    def _gen_pow(g, p):
        if p == 0: return ''
        if p == 1: return str(g)
        return str(g) + POW + str(p)
    def _filter_list(l):
        return [_ for _ in l if len(_)]
    def _concat(coeff_str, monom_str):
        if len(monom_str)==0 and coeff_str.endswith('*'):
            return coeff_str[:-1] # + monom_str
        return coeff_str + monom_str
    def _get_monom_str(monom):
        return MUL.join(_filter_list([_gen_pow(gens[i], monom[i]) for i in range(nvars)]))
    def get_string(monom, coeff):
        if not any(monom): # constant
            if coeff == 1: return '+1'
            if coeff == -1: return '-1'
            return _get_coeff_str(coeff, MUL)
        coeff_str = _get_coeff_str(coeff, MUL)
        return _concat(coeff_str, _get_monom_str(monom))

    strings = []
    for _, monom, coeff in extracted:
        order = get_order(monom)
        coeff = coeff / order
        strings.append(get_string(monom, coeff))
    s = ''.join(strings)
    if s.startswith('+'):
        s = s[1:]
    if _is_cyc:
        s = 's(%s)'%s
    else:
        s = '(%s)'%s
    return s





def _reduce_factor_list(poly: Poly, perm_group: PermutationGroup) -> Tuple[Expr, List[Tuple[Poly, int]], List[Tuple[Poly, int]]]:
    """
    Reduce the factor list of a polynomial with respect to a permutation group.

    Parameters
    ----------
    poly : Poly
        The polynomial to be factorized.
    perm_group : PermutationGroup
        The permutation group to be considered.

    Returns
    -------
    Tuple[Expr, List[Tuple[Poly, int]], List[Tuple[Poly, int]]]
        The reduced coefficient, the reduced parts, and the cyclic parts.

    Examples
    --------
    >>> _reduce_factor_list((b**8*a**6*c**3*(a**2+b*c)*(b**2+c*a)*(a-b)**7*(b-c)**6*(c-a)**8).as_poly(a,b,c), CyclicGroup(3))
    (1,
     [(Poly(b, a, b, c, domain='ZZ'), 5),
      (Poly(a*c + b**2, a, b, c, domain='ZZ'), 1),
      (Poly(a, a, b, c, domain='ZZ'), 3),
      (Poly(a - b, a, b, c, domain='ZZ'), 1),
      (Poly(a - c, a, b, c, domain='ZZ'), 2),
      (Poly(a**2 + b*c, a, b, c, domain='ZZ'), 1)],
     [(Poly(c, a, b, c, domain='ZZ'), 3), (Poly(b - c, a, b, c, domain='ZZ'), 6)])
    """
    coeff, factors = poly.factor_list()
    pow_dict = dict((p, power) for p, power in factors)
    rep_dict = dict((p.rep, p) for p, _ in factors)
    cyc_factors = []
    for base, power in factors:
        subdict = defaultdict(int)
        representative = base
        sign = 1
        for p in perm_group.elements:
            permed_base = base.reorder(*p(poly.gens)).rep
            permed_poly = rep_dict.get(permed_base)
            if permed_poly is None:
                permed_poly = rep_dict.get(-permed_base)
                sign *= -1
            if permed_poly is None:
                break
            subdict[permed_poly] += 1
            if pow_dict[permed_poly] < subdict[permed_poly]:
                break
            if permed_poly.compare(representative) < 0:
                representative = permed_poly
        else:
            # get max common power
            d = min(pow_dict[p]//v for p, v in subdict.items())
            if sign == -1 and d % 2 == 1: coeff = -coeff
            for p, v in subdict.items():
                pow_dict[p] -= d * v
                if pow_dict[p] == 0:
                    del pow_dict[p]
                    del rep_dict[p.rep]
            cyc_factors.append((representative, d))
    return coeff, list(pow_dict.items()), cyc_factors


def poly_get_factor_form(
        poly: Poly,
        perm: Optional[PermutationGroup] = None,
        omit_mul: bool = True,
        omit_pow: bool = True,
        # return_type: str = 'text',
    ) -> str:
    """
    Get the factorized form of a polynomial.

    Parameters
    ----------
    poly : Poly
        The polynomial to be factorized.
    perm : PermutationGroup
        The permutation group to be considered. If None,
        it uses the cyclic group generated by the variables.
    omit_mul : bool
        Whether to omit the multiplication sign. Defaults to True.
    omit_pow : bool
        Whether to omit the power sign. Defaults to True.
    """
    if poly.total_degree() == 0:
        return poly_get_standard_form(poly, perm, omit_mul, omit_pow)

    if perm is None:
        perm = CyclicGroup(len(poly.gens))

    coeff, factors, cyc_factors = _reduce_factor_list(poly, perm)

    MUL = '*' if not omit_mul else ''
    POW = '^' if not omit_pow else ''

    strings = []

    def get_pow_string(base: Poly, power: Integer):
        if base.is_monomial:
            if power == 1: return str(base.as_expr())
            return '%s%s%s'%(base.as_expr(), POW, power)

        base = poly_get_standard_form(base, perm, omit_mul, omit_pow)
        if _is_single_paren(base): pass
        elif base.startswith('s(') and _is_single_paren(base[1:]): pass
        else: base = '(%s)'%base
        if power == 1: return base
        return '%s%s%s'%(base, POW, power)

    def get_cyc_pow_string(base: Poly, power: Integer):
        s = get_pow_string(base, power)
        if s.startswith('('): s = 'p%s'%s
        else: s = 'p(%s)'%s
        return s

    for base, power in factors:
        strings.append(get_pow_string(base, power))
    for base, power in cyc_factors:
        strings.append(get_cyc_pow_string(base, power))

    strings = sorted(strings, key = lambda x: (len(x), x))
    s = _get_coeff_str(coeff, MUL) + MUL.join(strings)
    if s.startswith('+'): s = s[1:]
    return s


def latex_coeffs(poly, tabular: bool = True, document: bool = True, zeros: str ='\\textcolor{lightgray}') -> str:
    """
    Return the LaTeX format of the coefficient triangle.

    Parameters
    ----------
    poly : Poly
        The polynomial to be factorized.
    tabular : bool
        Whether to use the tabular environment.
    document : bool
        If True, it will be wrapped by an additional arraystretch command.
    zeros : str
        The color of the zeros.
    """
    if poly is None:
        return ''
    if isinstance(poly, str):
        poly_str = poly
        poly = pl(poly)
    else:
        poly_str = 'f(%s)'%','.join([str(_) for _ in poly.gens])

    zero_wrapper = lambda x: x
    if zeros is not None and len(zeros):
        zero_wrapper = lambda x: '%s{%s}'%(zeros, x)

    n = deg(poly)
    emptyline = '\\\\ ' + '\\ &' * (n * 2) + '\\  \\\\ '
    strings = ['' for i in range(n+1)]

    coeffs = poly.coeffs()
    monoms = poly.monoms()
    monoms.append((-1,-1,0))  # tail flag
    t = 0
    for i in range(n+1):
        for j in range(i+1):
            if monoms[t][0] == n - i and monoms[t][1] == i - j:
                txt = latex(coeffs[t])
                t += 1
            else:
                txt = zero_wrapper('0')
            strings[j] = strings[j] + '&\\ &' + txt if len(strings[j]) != 0 else txt
    monoms.pop()

    for i in range(n+1):
        strings[i] = '\\ &'*i + strings[i] + '\\ &'*i + '\\ '
    s = emptyline.join(strings)
    if tabular:
        s = '\\left[\\begin{matrix}\\begin{tabular}{' + 'c' * (n * 2 + 1) + '} ' + s
        s += ' \\end{tabular}\\end{matrix}\\right]'
    else:
        s = '\\left[\\begin{matrix} ' + s
        s += ' \\end{matrix}\\right]'

    s = (' \\\\ '.join(s.split('\\\\')[::2]))
    s = s.replace('&\\','& \\')
    if document:
        s = '\\renewcommand*{\\arraystretch}{1.732}$' + s + '$'
        # s = '\\textnormal{'+ poly_str +'  =}\n' + s
    return s