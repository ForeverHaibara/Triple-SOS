import sympy as sp
from mpmath import pslq

from .root_guess import rationalize

class RootTangent():
    def __init__(self, s, degree = None, coor = None, uv = None, is_strict = False):
        self.s = s
        self.degree_ = degree
        self.coor_ = coor
        self.uv_ = uv
        self.is_strict_ = is_strict

    def __str__(self):
        return self.s

    @property
    def degree(self):
        return self.degree_

    @property
    def coor(self):
        return self.coor_

    @property
    def uv(self):
        return self.uv_

    def __len__(self):
        return len(self.s)


def root_tangents(roots, strict_roots = [], tol=1e-6, rounding=1e-5, mod=(180,252,336)):
    """
    Generate possible tangents according to the roots given. 

    Linear, quadratic and cubic tangents have been implemented. 

    Linear: ka + b - c

    Quadratic: a^2 - b^2 - p (ac - ab) + q (bc - ab)

    Cubic: a^2c - b^2c + u (a^2b - abc) + v (ab^2 - abc)

    Roots and coefficients of the tangents are guessed into possible fraction forms. 

    Params
    -------
    roots: list of tuples
        Containing (a,b) where (a,b,1) is possibly some local minima.

    tol: float
        
    rounding: float
        Rounding used for rationalization. Do not set to too large because 
        backward errors are inevitable in gradient descent.
    
    mod: unsigned int / tuple ...
        Denominator guess for rationalization. Do not set to too large because 
        backward errors are inevitable in gradient descent.

    Return
    -------
    tangents: list of str
        a list of str that are tangents generated by the roots.
    """
    if not roots:
        return []

    uncentered = True
    for a, b in roots:
        if abs(a - 1) < 1e-3 and abs(b - 1) < 1e-3:
            uncentered = False
            break

    tangents = []
    for root in roots:
        a , b = root
        if b == 0:
            tangents += _root_tangents_border(a, b, rounding = rounding, uncentered = uncentered)
        else:
            # Great available knowledge on Vasc / Vasile
            if abs(a - 0.643104) < tol and abs(b - 0.198062) < tol:
                for s in ['b2+a2-2ab-bc','2c2+ab-3ac-bc','a2-b2-ac+2bc-ab','s(a3-a2b-2ab2+2abc)',
                    '2ab2-ca2-a2b-bc2+c2a','3a3+3b3-6c3+3b2c-c2a-2a2b-2bc2+16ca2-14ab2','s(2a2b-3ab2+abc)',
                    '16a3-38a2b+a2c+17ab2+15abc-6ac2-6b2c+bc2','a3c+bc3+a2bc+4ab2c-5abc2-2ab3',
                    'a2b+b2c+c2a-6abc'
                ]:
                    tangents.append(RootTangent(s, coor = root, uv = (1,2), is_strict = True))
                continue
            elif abs(a - 0.198062) < tol and abs(b - 0.643104) < tol:
                for s in [
                    'b2+c2-2cb-ba', '2a2+cb-3ca-ba', 'a2-b2+ab+bc-2ac', 's(c3-c2b-2cb2+2abc)', 
                    '2cb2-ac2-c2b-ba2+a2c', '3c3+3b3-6a3+3b2a-a2c-2c2b-2ba2+16ac2-14cb2', 's(2c2b-3cb2+abc)',
                    '16c3-38c2b+c2a+17cb2+15cba-6ca2-6b2a+ba2','c3a+ba3+c2ba+4cb2a-5cba2-2cb3',
                    'ab2+bc2+ca2-6abc'
                ]:
                    tangents.append(RootTangent(s, coor = root, uv = (2,1), is_strict = True))

                continue

            a = rationalize(a, rounding=1e-3, mod=mod)
            b = rationalize(b, rounding=1e-3, mod=mod)
            if b[0] == 0 and a[0] != 0 and a[1] != -1:
                tangents += [f'{a[1]}/{a[0]}*(a-b)+b-c']
        
        is_strict = root in strict_roots

        a , b = root
        tangents += _root_tangents_quadratic(a, b, rounding = rounding, strict = is_strict, uncentered = uncentered)
        
        # Cubic
        tangents += _root_tangents_cubic(a, b, rounding = rounding, strict = is_strict, uncentered = uncentered)

    tangents = list(set(tangents))
    
    return tangents


def _root_tangents_quadratic(a, b, rounding = 1e-3, strict = False, uncentered = False):
    """
    Generate quadratic tangents from root (a, b, 1).

    a^2 - b^2 + u(ab - ac) + v(bc - ab)

    Sometimes roots are irrational, but coefficients are not
    e.g. roots (a,b,1) = (0.307974173856697, 0.198058832471963, 1)
        By some numerical calculation, they are roots of 
        u = 3.0000275840807333 ,  v = 5.000061226507757
        where (u, v) = (3,5) is a confident guess

    """

    frac = lambda x: sp.Rational(*rationalize(x, rounding = rounding))
    tangents = []

    # trivial case
    if abs(b) < 1e-6 or (abs(a - 1) < 1e-6 and abs(b - 1) < 1e-6):
        return tangents


    t = ((a*b-a)*(a-b)-(b*(a-1))**2)
    if abs(t) < 1e-4:
        return tangents

    # basic quadratic form
    u = ((b*b-a*a)*(a-b) - (b-a*b)*(1-b*b))/t
    v = ((a*b-a)*(1-b*b)-(b*b-a*a)*(b-b*a))/t
    u, v = frac(u), frac(v)
    u_, v_ = u, v
    tangents.append(
        RootTangent(
            f'a2-b2+{u}(ab-ac)+{v}(bc-ab)',
            degree = 2,
            coor = (a, b),
            uv = (u, v),
            is_strict = strict
        )
    )


    # uncentered
    if not uncentered:
        return tangents
    
    u = a * b + a + b 
    if abs(u) > 1e-3:
        v = frac((a*a + b*b + 1) / u)
        if v != 1 and v > 1e-3:
            tangents.append(
                RootTangent(
                        f'a2+b2+c2-{v}*(ab+bc+ca)',
                        degree = 2,
                        coor = (a, b),
                        uv = (u_, v_),
                        is_strict = strict
                )
            )

    return tangents


def _root_tangents_cubic(a, b, rounding = 1e-3, strict = False, uncentered = False):
    """
    Generate cubic root tangents.
    """
    frac = lambda x: sp.Rational(*rationalize(x, rounding = rounding))
    tangents = []

    t = ((a*b-a)*(a-b)-(b*(a-1))**2)
    if abs(t) < 1e-4:
        return tangents

    u = ((b*b-a*a)*(a-b) - (b-a*b)*(1-b*b))/t
    v = ((a*b-a)*(1-b*b)-(b*b-a*a)*(b-b*a))/t
    u_, v_ = frac(u), frac(v)

    if u * v < 1 + 1e-3:
        return tangents

    tangentfy = lambda s: RootTangent(s, degree = 3, coor = (a, b), uv = (u_, v_), is_strict = strict)

    # 1. companion
    p = (u*u + v) / (u*v - 1)
    q = (v*v + u) / (u*v - 1)
    p, q = frac(p), frac(q)
    tangents.append(tangentfy(f'a2c-b2c-{p}(a2b-abc)+{q}(ab2-abc)'))


    if strict and abs(u - v) > 1e-4:
        formatter = lambda x: ('+' if x == 1 else '+%s'%x) if x >= 0 else ('-' if x == -1 else '%s'%x)
        # 2. umbrella
        coeffs = [1 - u*v, u**2*v - u, u**3 - u**2*v - u**2 + u*v + u - v, -u**3 - 1, u**2 + v]
        coeffs = [formatter(frac(_ / coeffs[0])) for _ in coeffs]
        tangents.append(tangentfy(f'a2c{coeffs[1]}ab2{coeffs[2]}abc{coeffs[3]}b2c{coeffs[4]}bc2'))

        # 3. scythe
        coeffs = [1 - u*v, u**3 - u**2*v - u**2 + u*v**2 + u*v + u - 2*v, u*v - 1, -u**3 + u**2*v - u*v**2 - u + v - 1, u**2 - u*v + v + 1]
        coeffs = [formatter(frac(_ / coeffs[0])) for _ in coeffs]
        tangents.append(tangentfy(f'a2c{coeffs[1]}abc{coeffs[2]}b3{coeffs[3]}b2c{coeffs[4]}bc2'))

        # 4. knife
        coeffs = [1 - u*v, -u**3 + u**2*v - u*v - u, u**3 - u**2 + u*v + u + v**2 - v, u**2 + v, -u**2*v + u*v - v**2 - 1]
        coeffs = [formatter(frac(_ / coeffs[0])) for _ in coeffs]
        tangents.append(tangentfy(f'a2c{coeffs[1]}ab2{coeffs[2]}abc{coeffs[3]}b3{coeffs[4]}b2c'))

    # uncentered
    if not uncentered:
        return tangents

    if abs(a) > 1e-3 and abs(b) > 1e-3:
        u = a * b
        v = ((a*a + b)*b + a) / u
        v = frac(v)
        if v != 1 and v > 1e-3:
            tangents.append(tangentfy(f'a2b+b2c+c2a-{v}abc'))
            
        v = ((b*b + a)*a + b) / u
        v = frac(v)
        if v != 1 and v > 1e-3:
            tangents.append(tangentfy(f'ab2+bc2+ca2-{v}abc'))

    return tangents


def _root_tangents_border(a, b, rounding = 1e-3, uncentered = False):
    """
    Generate tangents when b == 0.
    """
    frac = lambda x: sp.Rational(*rationalize(x, rounding = rounding))
    tangents = []

    # assert b == 0
    # on the edge (a,0,1) where a might be symbolic
    if isinstance(a, sp.Float):
        if a < 1e-3:
            return tangents
        elif abs(a - 1) < 1e-3:
            tangents.append(RootTangent('a+b-c', degree = 1, coor = (a, b)))
        else:
            a_ = frac(a)
            if a_.q < 100 or abs(a_.p) < 100:
                # (1/a)*a + (1-1/a)*b - c
                if a_ > 1:
                    tangents.append(RootTangent(f'{1/a_}a+{1-1/a_}b-c', degree = 1, coor = (a, b)))
                else:
                    tangents.append(RootTangent(f'{1/a_}a-{1/a_-1}b-c', degree = 1, coor = (a, b)))

            pslq_result = pslq([a*a, a, 1])
            if pslq_result is not None:
                u, v, w = pslq_result
                bound = 20
                if u != 0 and w != 0 and all(abs(i) < bound for i in (u, v, w)):
                    if u < 0:
                        u, v, w = -u, -v, -w
                    u, v, w = sp.S(u), sp.S(v), sp.S(w)
                    tangents.append(RootTangent(f'{u}a2+{v}ac+{w}c2', degree = 2, coor = (a, b)))
                    t = - u - v - w - w*w/u - w*v/u
                    tangents.append(RootTangent(f'{u}a2+{v}ac+{w}c2+{w*w/u}b2+{w*v/u}bc+{t}ba', degree = 2, coor = (a, b)))
                    t = - u - v - w - u*u/w - u*v/w
                    tangents.append(RootTangent(f'{w}c2+{v}ac+{u}a2+{u*u/w}b2+{u*v/w}ba+{t}bc', degree = 2, coor = (a, b)))

    else:
        # Temporarily Deprecated
        if a != 0 and a != 1:
            if isinstance(a, sp.Rational):
                # (1/a)*a + (1-1/a)*b - c
                tangents.append(f'{1/a}*a+{1-1/a}*b-c')
            elif a.is_real is not None:
                # is_real is a fast way to check whether it is a simple expression
                # e.g. cubic roots with imaginary unit returns None when querying is_real
                
                # e.g. x*x-5*x+1   -> a*a-5*a*c+c*c + b*b-5*b*c + 7*b*a
                try:
                    mini_poly = sp.minimal_polynomial(a).as_poly()
                    if mini_poly.degree() == 2:
                        u , v , w = mini_poly.all_coeffs()
                        tangents.append(f'{u}a2+{v}ac+{w}c2')
                        t = - u - v - w - w*w/u - w*v/u
                        tangents.append(f'{u}a2+{v}ac+{w}c2+{w*w/u}b2+{w*v/u}bc+{t}ba')
                        t = - u - v - w - u*u/w - u*v/w
                        tangents.append(f'{w}c2+{v}ac+{u}a2+{u*u/w}b2+{u*v/w}ba+{t}bc')
                        # a = (complex(a).real, -1)

                        # Symmetric Forms 
                        if abs(a) > 1e-3:
                            v = complex(a + 1 / a).real
                            v = frac(v)
                            if v > 1e-3 and v != 1:
                                tangents += [f'a2+b2+c2-{v}*(ab+bc+ca)']
                except: 
                    # sympy.polys.polyerrors.NotAlgebraic: 
                    # 0.932752395204472 doesn't seem to be an algebraic element
                    pass 
        elif a == 1:
            tangents.append(RootTangent('a+b-c', degree = 1, coor = (a, b)))

    return tangents