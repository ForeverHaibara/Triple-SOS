from functools import partial
from typing import Union, Tuple, List, Dict, Optional, Any, Callable

from sympy import Expr, Poly, Symbol, Function

from .abstract import AtomSOSElement
from .algebra import MixedMomentAlgebra
from .solution import SolutionSDP

class SOSMomentPoly(AtomSOSElement):
    """
    SOSMomentPoly represents a commutative polynomial in the algebra generated by symbols
    and moments of monomials. See detailed theory in [1] and [2].

    The class is still very experimental.

    References
    -----------
    [1] Klep, I., Magron, V., & Vol훾i훾, J. (2023). Sums of squares certificates for polynomial moment inequalities.
    [2] Klep, I., Magron, V., Vol훾i훾, J., & Wang, J. (2023). State polynomials: positivity, optimization
        and nonlinear Bell inequalities. Math. Program., 207, 645-691.

    Examples
    ---------

    ### Proving Cauchy-Schwarz Inequality

    Consider the inequality `E(a**2)*E(b**2) - E(a*b)**2 >= 0` where E is a positive linear operator
    and a and b are some "abstract" real variables (e.g., random variables). It can be proved via
    sum-of-squares of `E(a**2)*(E(a**2)*E(b**2) - E(a*b)**2)`. To apply the `SOSMomentPoly`,
    we should init it with the expression and sets the state (moment) operator to be `E`.

        >>> from sympy.abc import a, b
        >>> from sympy import Function
        >>> E = Function('E')
        >>> sos = SOSMomentPoly(E(a**2)*(E(a**2)*E(b**2) - E(a*b)**2), [a, b], [1], state_operator=E)
        >>> sos.solve()
        Matrix([[1]])
        >>> sos.as_solution().solution
        E((a*E(a*b) - b*E(a**2))**2)
    """
    _state_operator = Function('\\Sigma')
    def __init__(self,
        poly: Union[Expr, Poly],
        gens: Tuple[Symbol,...],
        qmodule: List[Union[Poly, Expr]] = [],
        ideal: List[Union[Poly, Expr]] = [],
        nvars: Optional[int] = None,
        degree: Optional[int] = None,
        num_moments: Optional[int] = None,
        standard_monom: Optional[Callable[[Tuple], Tuple]] = None,
        state_operator: Optional[Callable[[Expr], Expr]] = None,
    ):
        gens = tuple(gens)
        as_poly = partial(MixedMomentAlgebra(len(gens), 0, 0, standard_monom=standard_monom).as_poly,
                     state_operator=state_operator)
        poly = as_poly(poly, gens)
        self.poly = poly
        self.gens = gens

        # TODO: this is not neat enough. Also, what if a qmodule is associated with multiple
        # basis? e.g. CORR SPARSITY
        if not isinstance(qmodule, dict):
            qmodule = dict(enumerate(qmodule))
        if not isinstance(ideal, dict):
            ideal = dict(enumerate(ideal))
        self._qmodule = {k: as_poly(v, gens) for k, v in qmodule.items()}
        self._ideal = {k: as_poly(v, gens) for k, v in ideal.items()}

        if degree is None:
            # degree = max([self.poly] + list(self._qmodule.values()) + list(self._ideal.values()),
            #                 key=lambda _: _.total_degree()).total_degree()
            degree = self.poly.total_degree()
        else:
            degree = int(degree)
            if degree < 0 or degree < self.poly.total_degree():
                raise ValueError("The degree should be nonnegative and no smaller than the total degree of the polynomial.")

        if nvars is None:
            nvars = len(gens)

        if num_moments is None:
            mom = lambda x: sum([mul for m, mul in x[1:]])
            num_moments = (max(map(mom, self.poly.monoms()), default=0))//2*2 + 1

        is_homogeneous = self.poly.is_homogeneous \
            and all(_.is_homogeneous for _ in self._qmodule.values()) \
            and all(_.is_homogeneous for _ in self._ideal.values()) \
            and self.poly.total_degree() == degree

        self.algebra = MixedMomentAlgebra(nvars, degree=degree,
                num_moments=num_moments, is_homogeneous=is_homogeneous,
                standard_monom=standard_monom)

        if state_operator is not None:
            self._state_operator = state_operator

    def _post_construct(self, verbose: bool = False, time_limit: Optional[Union[Callable, float]] = None, **kwargs):
        self.sdp.constrain_zero_diagonals(time_limit=time_limit)

    def as_solution(
        self,
        qmodule: Optional[Dict[Any, Expr]] = None,
        ideal: Optional[Dict[Any, Expr]] = None,
        state_operator: Optional[Callable[[Expr], Expr]] = None,
    ) -> SolutionSDP:
        """
        Retrieve the solution to the original polynomial.

        Parameters
        ----------
        qmodule: Optional[Dict[Any, Expr]]
            Conversion of polynomial inequality constraints to sympy expression forms.
        ideal: Optional[Dict[Any, Expr]]
            Conversion of polynomial equality constraints to sympy expression forms.
        """
        decomp = self.sdp.decompositions
        if decomp is None:
            raise ValueError("The problem has not been solved yet.")
        decomp = {k[1]: v for k, v in decomp.items() if k[0] is self} # remove the prefix

        qmodule = self._qmodule if qmodule is None else qmodule
        ideal = self._ideal if ideal is None else ideal
        if not isinstance(qmodule, dict):
            qmodule = dict(enumerate(qmodule))
        if not isinstance(ideal, dict):
            ideal = dict(enumerate(ideal))

        eqspace = {eq: x + space * self.sdp.y for eq, (x, space) in self._ideal_space.items()}

        if state_operator is None:
            state_operator = self._state_operator

        solution = SolutionSDP.from_decompositions(self.poly, decomp, eqspace,
            qmodule          = qmodule,
            qmodule_bases    = self._qmodule_bases,
            ideal            = ideal,
            ideal_bases      = self._ideal_bases,
            state_operator   = state_operator
        )

        # overwrite the constraints information in the form of dict((Poly, Expr))
        solution.ineq_constraints = {self._qmodule[key]: expr for key, expr in qmodule.items()}
        solution.eq_constraints = {self._ideal[key]: expr for key, expr in ideal.items()}
        return solution
