from typing import List, Tuple, Dict, Union, Optional, Any

from sympy import Expr, Poly
from sympy.matrices import MutableDenseMatrix as Matrix
from sympy.combinatorics import PermutationGroup, Permutation

from ....sdp.arithmetic import rep_matrix_from_dict

MONOM = Any
TERM = Tuple[MONOM, Expr]



class StateAlgebra:
    """
    Most general abstract class for algebra covering multiple applications,
    representing a noncommutative algebra equipped with a state (positive linear functional) operator.

    Consider a noncommutive free algebra A generated by (a_1, ..., a_n). The words (monomials)
    in A are of the form:

        w = a_i1 ^ k1 * a_i2 ^ k2 * ... * a_im ^ km, where i_j is in {1,..., n}.

    Noncommutative polynomials in A are linear combinations of the words.

    Consider a positive linear functional s: A -> R. To define s on all polynomials in A,
    it suffices to define s on all monomials. Thus we have an infinite collection of states
    of words:

        s(A) = {s(word) for word in A}

    If we treat s(A) as a collection of new (commutative scalar) variables, we can define the
    new algebra B generated by (a1, ..., an) + s(A). Each word in A' is of the form:

        w' = s(w1)*s(w2)*...*s(wm) * w

    where w0, ..., wm are all words in A. The linear combinations of w' in A' are polynomials.
    An element in A' is called pure if it is a linear combination of product of states.

    If we assume a1, ..., an are self-adjoint (hermitian), we can define
    """
    is_commutative = False
    is_cyclic_equivalent = False # if True, s(AB) = s(BA) holds, e.g., trace operators

    # Symmetry is a permutation group if not None
    # indicating the symmetry of monomials, the invariance of expression in the order of generators
    symmetry: Optional[PermutationGroup] = None

    _dict_monoms: Dict[MONOM, int] # monom: index
    _inv_monoms: List[MONOM] # index: monom

    def __len__(self):
        return len(self._dict_monoms)

    def index(self, monom: MONOM) -> int:
        # return self._dict_monoms[monom]
        i = self._dict_monoms.get(monom)
        if i is None:
            raise ValueError(f"Unexpected monom {monom} in {self}")
        return i

    def inv_monoms(self) -> List[MONOM]:
        return self._inv_monoms

    def permute_monom(self, monom: MONOM, perm: Permutation) -> MONOM:
        raise NotImplementedError

    def permute(self, monom: MONOM) -> List[MONOM]:
        if self.symmetry is None:
            return [monom]
        pm = self.permute_monom
        return [pm(monom, p) for p in self.symmetry.elements]

    def is_symmetric(self, poly: Poly, perm: Optional[Union[Permutation, PermutationGroup]]=None) -> bool:
        if perm is None:
            perm = self.symmetry
            if perm is None:
                return True
        terms = dict(self.terms(poly))
        pm = self.permute_monom
        def _check_single(p):
            return all(terms.get(pm(m, p)) == v for m, v in terms.items())
        if isinstance(perm, Permutation):
            return _check_single(perm)
        if isinstance(perm, PermutationGroup):
            return all(_check_single(p) for p in perm.elements)
        return all(_check_single(p) for p in perm)

    def s(self, term: TERM) -> TERM:
        raise NotImplementedError

    def terms(self, poly: Poly) -> List[TERM]:
        return poly.rep.terms()

    def arraylize(self, poly: Poly, state: bool = False) -> Matrix:
        vec = {}
        for monom, coeff in self.terms(poly):
            ind = self._dict_monoms.get(monom)
            if ind is None:
                continue
            vec[ind] = {0: coeff}
        return rep_matrix_from_dict(vec, (len(self), 1), poly.domain)

    def mul(self, term1: TERM, term2: TERM) -> TERM:
        raise NotImplementedError

    def adjoint(self, term: TERM) -> TERM:
        raise NotImplementedError

    def infer_bases(self, poly: Poly, qmodule: Dict[Any, Poly], ideal: Dict[Any, Poly],
            **kwargs) -> Tuple[Dict[Any, Any], Dict[Any, Any]]:
        raise NotImplementedError


class CommutativeStateAlgebra(StateAlgebra):
    """
    Abstract class for commutative state algebra. This is also something like "moment algebra".
    All elements must be commutative. And it must have the property:

        A.mul(x, y) == A.mul(y, x)
    """
    is_commutative = True
    is_cyclic_equivalent = True

    def adjoint(self, term: TERM) -> TERM:
        return term

