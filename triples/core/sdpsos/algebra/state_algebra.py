from typing import List, Tuple, Dict, Union, Optional, Any

from sympy import Expr, Poly
from sympy.matrices import MutableDenseMatrix as Matrix
from sympy.combinatorics import PermutationGroup, Permutation

from ....sdp.arithmetic import rep_matrix_from_dict

MONOM = Any
TERM = Tuple[MONOM, Expr]



class StateAlgebra:
    """
    Most general abstract class for algebra covering multiple applications,
    representing a noncommutative algebra equipped with a state (positive linear functional) operator.

    Consider a noncommutive free algebra A generated by (a_1, ..., a_n). The words (monomials)
    in A are of the form:

        w = a_i1 ^ k1 * a_i2 ^ k2 * ... * a_im ^ km, where i_j is in {1,..., n}.

    Noncommutative polynomials in A are linear combinations of the words.

    Consider a positive linear functional s: A -> R. To define s on all polynomials in A,
    it suffices to define s on all monomials. Thus we have an infinite collection of states
    of words:

        s(A) = {s(word) for word in A}

    If we treat s(A) as a collection of new (commutative scalar) variables, we can define the
    new algebra B generated by (a1, ..., an) + s(A). Each word in A' is of the form:

        w' = s(w1)*s(w2)*...*s(wm) * w

    where w0, ..., wm are all words in A. The linear combinations of w' in A' are polynomials.
    An element in A' is called pure if it is a linear combination of product of states.

    If we assume a1, ..., an are self-adjoint (hermitian), we can define
    """
    is_commutative = False
    is_cyclic_equivalent = False # if True, s(AB) = s(BA) holds, e.g., trace operators

    # Symmetry is a permutation group if not None
    # indicating the symmetry of monomials, the invariance of expression in the order of generators
    symmetry: Optional[PermutationGroup] = None

    _dict_monoms: Dict[MONOM, int] # monom: index
    _inv_monoms: List[MONOM] # index: monom

    def __len__(self):
        """Number of monomials in the (degree-truncated) algebra."""
        return len(self._dict_monoms)

    def index(self, monom: MONOM) -> int:
        """Index of a monomial in the (degree-truncated) algebra."""
        # return self._dict_monoms[monom]
        i = self._dict_monoms.get(monom)
        if i is None:
            raise ValueError(f"Unexpected monom {monom} in {self}")
        return i

    def inv_monoms(self) -> List[MONOM]:
        """Get the mapping `inv_monoms[i] = monom` of the algebra."""
        return self._inv_monoms

    def total_degree(self, monom: MONOM) -> int:
        """Compute the total degree of a monomial."""
        raise NotImplementedError

    def permute_monom(self, monom: MONOM, perm: Permutation) -> MONOM:
        """Permute a monomial given a permutation over the generators."""
        raise NotImplementedError

    def permute(self, monom: MONOM) -> List[MONOM]:
        """Get all elements in the orbit of a monomial of self's permutation group."""
        if self.symmetry is None:
            return [monom]
        pm = self.permute_monom
        return [pm(monom, p) for p in self.symmetry.elements]

    def is_symmetric(self, poly: Poly, perm: Optional[Union[Permutation, PermutationGroup]]=None) -> bool:
        """
        Decide whether a polynomial is symmetric with respect to a permutation
        or a permutation group in the algebra.
        """
        if perm is None:
            perm = self.symmetry
            if perm is None:
                return True
        terms = dict(self.terms(poly))
        pm = self.permute_monom
        def _check_single(p):
            return all(terms.get(pm(m, p)) == v for m, v in terms.items())
        if isinstance(perm, Permutation):
            return _check_single(perm)
        if isinstance(perm, PermutationGroup):
            return all(_check_single(p) for p in perm.elements)
        return all(_check_single(p) for p in perm)

    def s(self, term: TERM) -> TERM:
        """Apply the state operator on a term."""
        raise NotImplementedError

    def terms(self, poly: Poly) -> List[TERM]:
        """
        Get the list of terms of a polynomial in the algebra.
        This is automatically implemented if the polynomial object has the method `.rep.terms()`.
        """
        return poly.rep.terms()

    def arraylize(self, poly: Poly, state: bool = False) -> Matrix:
        """
        Convert a polynomial to a sympy vector (Matrix). The polynomial
        should lie in the algebra. Monomials outside the (degree-truncated)
        algebra will be automatically ignored.
        """
        vec = {}
        for monom, coeff in self.terms(poly):
            ind = self._dict_monoms.get(monom)
            if ind is None:
                continue
            vec[ind] = {0: coeff}
        return rep_matrix_from_dict(vec, (len(self), 1), poly.domain)

    def as_expr(self, poly: Poly) -> Expr:
        """Convert a polynomial in this algebra to sympy Expr."""
        raise NotImplementedError

    def mul(self, term1: TERM, term2: TERM) -> TERM:
        """Define the product of two terms (monom1, coeff1) * (monom2, coeff2)."""
        raise NotImplementedError

    def adjoint(self, term: TERM) -> TERM:
        """
        Define the complex adjoint of a term (monom, coeff). For commutative
        real algebras, this should be the identity.
        """
        raise NotImplementedError

    def infer_bases(self, poly: Poly, qmodule: Dict[Any, Poly], ideal: Dict[Any, Poly],
            **kwargs) -> Tuple[Dict[Any, Any], Dict[Any, Any]]:
        """
        Get default bases for an SOS problem given the polynomial, qmodule and ideal.
        """
        raise NotImplementedError


class CommutativeStateAlgebra(StateAlgebra):
    """
    Abstract class for commutative state algebra. This is also something like "moment algebra".
    All elements must be commutative. And it must have the property:

        A.mul(x, y) == A.mul(y, x)
    """
    is_commutative = True
    is_cyclic_equivalent = True

    def adjoint(self, term: TERM) -> TERM:
        return term

